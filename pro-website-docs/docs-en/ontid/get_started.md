<h1 align="center">ONT ID Application Development Guide </h1>

We assume that you already know the concept of the ONT ID and know what the ONT ID can do for you. Now you need to use ONT ID to authenticate you users or use ONT ID to manage digital identities for your users. You can start with this document.

We support multiple SDK or RPC methods to apply ONT ID. We use the Typescript SDK as an example to illustrate how to develop quickly. The following sample code in this document uses the Node environment.

## 1. Environment Preparation

Please refer to [Ontology TS SDk Installation Guide](https://github.com/ontio/ontology-ts-sdk) to install the environment。

## 2. Create Digital Identitiy

### 2.1 Create Identity

ONT ID is a decentralized identity that manages the user's various digital identity authentications. Digital Identity (Identity) is a core class exported by the ONT SDK. This class contains the ONT ID attribute that represents identity.

> For detailed information about digital identity, please refer to[ONT ID Protocol Specifiction](https://github.com/ontio/ontology-DID/blob/master/docs/cn/ONTID_protocol_spec_cn.md)。

You can create an identity through the SDKs. The ONTT ID is generated based on the user's private key during the process.

The parameters needed are as follows:

**privateKey** User's privatekey.The private key can be safely generated by the method provided by the SDK.

**password** The password used to encrypt and decrypt the private key。

**label** Name of Identity

**params** The parameter used to encrypt the private key. Optional parameters. Default values ​​of the optional parameters are as follows:

```
{
    cost: 4096,
    blockSize: 8,
    parallel: 8,
    size: 64
}
```

```
import {Identity, Crypto} from 'ontology-ts-sdk';
//generate a random private key
const privateKey = Crypto.PrivateKey.random();

var identity = Identity.create(privateKey, password, label)
console.log(identity.ontid)
```

### 2.2 Register the ONT ID on the blockchain

After the identity is created, you need to register the identity ONT ID on the blockchain, and the identity is actually created.

Sending an ONT ID to the blockchain is a process that requires a transaction to be sent. The transaction object can be constructed by calling the methods provided by the SDKs.

A typical scenario is to construct a transaction object by passing the ONT ID and the user's private key.

Passing the privatekey has two purposes:

1. Sign the constructed transaction;

2. Bind the user's ONT ID to the public key that corresponds to the user's private key. The user can then add other public keys to the ONT ID.

````
import {OntidContract} from 'ontology-ts-sdk';
import {TransactionBuilder} from 'ontology-ts-sdk'

//suppose we already got a identity
const did = identity.ontid;
//we need the public key, which can be generate from private key
const pk = privateKey.getPublicKey();
const gasPrice = '0';
const gasLimit = '20000;
const tx = OntidContract.buildRegisterOntidTx(did, pk, gasPrice, gasLimit);
Transaction.signTransaction(tx, privateKey);
````

Transactions that send ONT IDs to the blockchain need a fee. We need to assign a Payer for the transaction and add the Payer's signature. The payer can be the user or the dApp application.

````
import {TransactionBuilder} from 'ontology-ts-sdk'
//we also need an account to pay for the gas
//supporse we have an account and the privateKey
tx.payer = account.address
//Then sign the transaction with payer's account
//we already got transaction created before,add the signature.
TransactionBuilder.addSign(tx, privateKeyOfAccount)
````

现在可以发送交易到链上。我们多种发送交易的方式，如Websocket, Restful和RPC。这里以Restful的方式为例。我们可以指定交易发送到的节点，如果不指定，默认发送到测试网。

Now the transaction can be sent to the chain. We have various methods to send the transactions, such as Websocket, Restful and RPC. Here is the example of the Restful method. We can specify the node to which the transaction is sent, or send the transaction to TestNet.
````
import {RestClient, CONST} from 'ontology-ts-sdk'

const rest = new RestClient(CONST.TEST_ONT_URL.REST_URL);
rest.sendRawTransaction(tx.serialize()).then(res => {
    console.log(res)
})
````

The result is as follows：

````
{ Action: 'sendrawtransaction',
  Desc: 'SUCCESS',
  Error: 0,
  Result: 'dfc598649e0f3d9ff94486a80020a2775e1d474b843255f8680a3ac862c58741',
  Version: '1.0.0' }
````

If the result is success (Error is 0), the ONT ID is successfully sent to the blockchian. We can query the information about the ONT ID on the blockchain.

The ONT ID creation process is actually completed when the callback function gets success information. Then you can use it through the ONT ID.


## 3. Query on-chain ID DDO

When an ONT ID is successfully registered on the blockchain, there is an ONT ID Object, called DDO, on the blockchain. The easiest way to query DDO is through the [Ontology Blockchain Browser] (https://explorer.ont.io). Or you can also query through the SDKs.

Method for querying through the SDKs is as follows:

First, creat a transaction
````
import {OntidContract} from 'ontology-ts-sdk';
//we use identity's ONT ID to create the transaction
const tx = OntidContract.buildGetDDOTx(identity.ontid)
````

Sending a transaction or querying a transaction does not require consumption of gas, and there is no need to specify the payer and the signature of the payer. The second parameter of the transaction-sending method indicates whether the pre-executed transaction was sent. The pre-executed transaction runs only on the node that receives it, not waiting for a consensus. Pre-executed transaction is generally used to query data.
````
import {RestClient} from 'ontology-ts-sdk';
const rest = new RestClient();
rest.sendRawTransaction(tx, true).then(res => {
    console.log(res);
}
````

The result is as follows:
````
{ Action: 'sendrawtransaction',
      Desc: 'SUCCESS',
      Error: 0,
      Result:
       { State: 1,
         Gas: 20000,
         Result: '26010000002103547c5abdbe66677ba7001cefd773f01a19c6360b15ee51c6db43911f046564fc0000' },
      Version: '1.0.0' }
````

Result is the serialized DDO (ONT ID object). We can get the detailed data through deserialization.
````
const ddo = DDO.deserialize(response.Result.Result);
console.log(ddo);
````
## 4. Authenticate the users and get the Claim

Based on ONTID and Ontology Trust Ecosystem, ONTPass is an open, decentralized authentication service platform that provides KYC (Know Your Customer) services and various user authentication services. Ontology Trust Ecosystem has gathered trust anchors that provide global identity authentication services, including IdentityMind, CFCA, Shangtang Technology, Shufti Pro, etc., as well as mailbox, mobile, and social media authentication methods.

[>> Use ONTPass](http://pro-docs.ont.io/#/docs-en/ontpass/overview)


## 5. Verify the varifiable claim

In the previous section we gave examples of how to obtain a third-party-issued identity claim that users can present when they need it. At the same time, whether these statements are true or falsified can be verified by the methods provided by the SDK.

We illustrate the process of verifying a verifiable claim by taking Alice's job haunting as an example.

When Alice hunt for a job in Company B, she provides a digital diploma issued by Fudan University, which is a JSON file that meets the claim format. Company B can verify the claim by calling the ONT SDK. The internal implementation logic of the method is first, to obtain the DDO information of the issuer by using the **Issuer** field in the claim, obtain the public key of the issuer from the DDO information, and check signature-removed content in the claim object, as well as the publickey and signature value. If the verification is passed, it indicates that the statement is true and valid.

The input parameter to this method is the JSON string declared by the claim, and the result is Promise. The verification results are processed in the callback method of Promise.


````
Core.verifyClaim(claim).then((result) => {
    //result is "verification result"
    if(result){
        //verificaton is passed
    } else {
        //verification is not passed
    }
})
````

## 6. Make a trusted statement for the user

 Your platform can also make verifiable claims for users.

> Any ONT ID owner can issue verifiable claim to himself or others.

> Government agencies, universities, banks, third-party certification services (such as CA institutions), biometric technology companies, etc. can be used as real trust institutions. They can be added as a specific partner to the ontology ecosystem.
If you are likely to become a certification service partner, please refer to[trust anchor]().

We use the digital diploma issued by Fudan University in China as an example to explain how to obtain the identity claim issued by a third party.

Suppose Alice is a student at Fudan University and applies for a digital certificate of the diploma from the university. After the school verifies the identity of Alice, it generates a verifiable claim by calling the API of the SDK, which contains Alice's graduation information and the signature of the statement with the school's private key.


````
var claim = SDK.signClaim(context, claimData, issuer, subject, privateKey)
````

The parameters of the method are described as follows:

**context** is an identifier for the claim template.

**claimData** is the specific content of the user's claim, the value is a JSON object. Here is the information on Alice's diploma, such as:


````
{
    "degree" : "bachelor",
    "year" : "2017",
    ......
}
````

**issuer** is the ONT ID of the issuer (here is Fudan University).

**subject** is the ONT ID of the claim recipient (here Alice). This indicates that the claim is bound to Alice's ONT ID.

**privateKey** is the issuer's private key. Used to sign a claim.

The content of the claim object returned by this method is similar to:

````
{
    .....
}
````


For specific standards of the declared object, see [Standards of the claim](https://github.com/ontio/ontology-DID/blob/master/docs/cn/claim_spec_cn.md).

Next you need to send the transaction to the blockchain for attestation. After the sending is successful, the integral certificate of the claim is returned. See the specific format of the certificate.

[claim integrity certificate]().

First you need to construct the transaction to be sent. Parameters to be passed:

**path** is the name of the key that the information of the claim is stored on the chain. This value is the Id in the claim object. This is a value generated after hashing the contents of the declared object.

**value** is the information of the claim that needs to be stored on the chain. The value is the following JSON structure:

````
{
    Context : string, //Identity of the claim template，
    Ontid : string //ONT ID of the claim-issuer
}
````

**ontid** ONT ID of the claim sender. That is, the ONT ID of the claim-issuer.

**privateKey** privatekey of the transaction sender. That is, privatekey of the claim-issuer.

````
var param = SDK.buildClaimTx(path, value, ontid, privateKey)
````

Next, build the tool class that sends the transaction and the callback method that listens for the message.

In the callback method, a proof about the integrity of the claim is returned after the claim is successfully on the blockchain. By adding this integrity proof to the previously constructed claim object, the user gets the full third-party certified claim object. The user can then provide the claim in a scenario that is needed.

````
//Here is an example of a Test Node.
var txSender = new TxSender(ONT_NETWORK.TEST)
const callback = function(res, socket) {
    let res 
    if(typeof event.data === 'string') {
    res = JSON.parse(event.data)
    //Parsing the background pushed Event notification
    //By simply judging the height of the block, it is known that the claim is successfuly on the blockchain.，
    if(res.Result.BlockHeight) {
      socket.close()
    }
}
txSender.sendTxWithSocket(param, callback)
````

The content of the proof is similar to the following：

````
{
    "Proof" : {
        "Type" : "MerkleProof",
        "TxnHash" : "aaa",
        "BlockHeight" : "1000",
        "MerkleRoot" : "aaaaaaa",
        "Nodes" : [
            {"Direction" : "Right", "TargetHash" : "aaaa"},
            {"Direction" : "Left", "TargetHash" : "bbbbb"}
        ]
    }
}
````





